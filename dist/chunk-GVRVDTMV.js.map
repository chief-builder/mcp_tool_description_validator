{"version":3,"sources":["../src/core/config.ts","../src/parsers/file.ts","../src/parsers/mcp-client.ts","../src/rules/index.ts","../src/core/rule-loader.ts","../src/core/rule-engine.ts","../src/core/validator.ts","../src/reporters/human.ts","../src/reporters/json.ts","../src/reporters/sarif.ts"],"sourcesContent":["/**\n * Configuration loading and management for MCP Tool Validator\n *\n * Uses cosmiconfig for flexible config file discovery and loading.\n * Supports: mcp-validate.config.yaml, mcp-validate.config.json, .mcp-validaterc, etc.\n */\n\nimport { cosmiconfig } from 'cosmiconfig';\nimport type { ValidatorConfig, RuleConfig, OutputConfig } from '../types/index.js';\n\n// ============================================================================\n// Default Configuration\n// ============================================================================\n\n/**\n * Default output configuration\n */\nconst DEFAULT_OUTPUT: OutputConfig = {\n  format: 'human',\n  verbose: false,\n  color: true,\n};\n\n/**\n * Default rule configurations (all rules enabled with default severities)\n */\nconst DEFAULT_RULES: RuleConfig = {\n  // Schema rules (SCH-xxx)\n  'SCH-001': true,\n  'SCH-002': true,\n  'SCH-003': true,\n  'SCH-004': true,\n  'SCH-005': true,\n  'SCH-006': true,\n  'SCH-007': true,\n  'SCH-008': true,\n\n  // Naming rules (NAM-xxx)\n  'NAM-001': true,\n  'NAM-002': true,\n  'NAM-003': true,\n  'NAM-004': true,\n  'NAM-005': true,\n  'NAM-006': true,\n\n  // Security rules (SEC-xxx)\n  'SEC-001': true,\n  'SEC-002': true,\n  'SEC-003': true,\n  'SEC-004': true,\n  'SEC-005': true,\n  'SEC-006': true,\n  'SEC-007': true,\n  'SEC-008': true,\n  'SEC-009': true,\n  'SEC-010': true,\n\n  // LLM compatibility rules (LLM-xxx)\n  'LLM-001': true,\n  'LLM-002': true,\n  'LLM-003': true,\n  'LLM-004': true,\n  'LLM-005': true,\n  'LLM-006': true,\n  'LLM-007': true,\n  'LLM-008': true,\n  'LLM-009': true,\n  'LLM-010': true,\n  'LLM-011': true,\n  'LLM-012': true,\n\n  // Best practice rules (BP-xxx)\n  'BP-001': true,\n  'BP-002': true,\n  'BP-003': true,\n  'BP-004': true,\n  'BP-005': true,\n  'BP-006': true,\n  'BP-007': true,\n  'BP-008': true,\n};\n\n/**\n * Complete default configuration\n */\nconst DEFAULT_CONFIG: ValidatorConfig = {\n  rules: DEFAULT_RULES,\n  output: DEFAULT_OUTPUT,\n};\n\n// ============================================================================\n// Configuration Loading\n// ============================================================================\n\n/**\n * Module name for cosmiconfig search\n */\nconst MODULE_NAME = 'mcp-validate';\n\n/**\n * Create a cosmiconfig explorer for configuration discovery\n */\nfunction createExplorer() {\n  return cosmiconfig(MODULE_NAME, {\n    searchPlaces: [\n      // YAML variants (preferred)\n      `${MODULE_NAME}.config.yaml`,\n      `${MODULE_NAME}.config.yml`,\n      // JSON variants\n      `${MODULE_NAME}.config.json`,\n      // RC file variants\n      `.${MODULE_NAME}rc`,\n      `.${MODULE_NAME}rc.yaml`,\n      `.${MODULE_NAME}rc.yml`,\n      `.${MODULE_NAME}rc.json`,\n      // Package.json\n      'package.json',\n    ],\n    packageProp: MODULE_NAME,\n  });\n}\n\n/**\n * Result from loading configuration\n */\nexport interface LoadConfigResult {\n  /** The merged configuration */\n  config: ValidatorConfig;\n  /** Path to the config file that was loaded, or null if using defaults */\n  filepath: string | null;\n}\n\n/**\n * Load configuration from various sources using cosmiconfig.\n *\n * Searches for configuration in the following order:\n * 1. Explicit config path (if provided)\n * 2. mcp-validate.config.yaml / mcp-validate.config.yml\n * 3. mcp-validate.config.json\n * 4. .mcp-validaterc (YAML or JSON)\n * 5. .mcp-validaterc.yaml / .mcp-validaterc.yml\n * 6. .mcp-validaterc.json\n * 7. \"mcp-validate\" key in package.json\n *\n * @param configPath - Optional explicit path to config file\n * @returns The loaded configuration merged with defaults, and the filepath\n */\nexport async function loadConfig(configPath?: string): Promise<LoadConfigResult> {\n  const explorer = createExplorer();\n\n  try {\n    let result;\n\n    if (configPath) {\n      // Load from explicit path\n      result = await explorer.load(configPath);\n    } else {\n      // Search for config file\n      result = await explorer.search();\n    }\n\n    if (result && !result.isEmpty) {\n      // Merge user config with defaults\n      const mergedConfig = mergeConfig(result.config as Partial<ValidatorConfig>);\n      return {\n        config: mergedConfig,\n        filepath: result.filepath,\n      };\n    }\n\n    // No config file found, use defaults\n    return {\n      config: getDefaultConfig(),\n      filepath: null,\n    };\n  } catch (error) {\n    // If config file exists but is invalid, throw the error\n    if (configPath) {\n      throw error;\n    }\n\n    // For search failures, fall back to defaults\n    return {\n      config: getDefaultConfig(),\n      filepath: null,\n    };\n  }\n}\n\n// ============================================================================\n// Configuration Merging\n// ============================================================================\n\n/**\n * Deep merge user configuration with defaults.\n *\n * Merging rules:\n * - User rules override default rules (false disables, severity overrides)\n * - User output settings override defaults\n * - LLM config is only present if user provides it\n *\n * @param userConfig - Partial user configuration\n * @returns Complete merged configuration\n */\nexport function mergeConfig(userConfig: Partial<ValidatorConfig>): ValidatorConfig {\n  const defaultConfig = getDefaultConfig();\n\n  // Merge rules: start with defaults, overlay user rules\n  const mergedRules: RuleConfig = {\n    ...defaultConfig.rules,\n    ...(userConfig.rules ?? {}),\n  };\n\n  // Merge output: start with defaults, overlay user settings\n  const mergedOutput: OutputConfig = {\n    ...defaultConfig.output,\n    ...(userConfig.output ?? {}),\n  };\n\n  // Build the merged config\n  const mergedConfig: ValidatorConfig = {\n    rules: mergedRules,\n    output: mergedOutput,\n  };\n\n  // Only include LLM config if user provides it\n  if (userConfig.llm) {\n    mergedConfig.llm = userConfig.llm;\n  }\n\n  return mergedConfig;\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Get a fresh copy of the default configuration.\n *\n * @returns Default ValidatorConfig with all rules enabled\n */\nexport function getDefaultConfig(): ValidatorConfig {\n  return {\n    rules: { ...DEFAULT_RULES },\n    output: { ...DEFAULT_OUTPUT },\n  };\n}\n\n/**\n * Get the default rules configuration.\n *\n * @returns Default RuleConfig with all rules enabled\n */\nexport function getDefaultRules(): RuleConfig {\n  return { ...DEFAULT_RULES };\n}\n\n/**\n * Check if a rule is enabled in the given configuration.\n *\n * @param config - Validator configuration\n * @param ruleId - Rule identifier (e.g., \"SEC-001\")\n * @returns true if the rule is enabled, false otherwise\n */\nexport function isRuleEnabled(config: ValidatorConfig, ruleId: string): boolean {\n  const ruleSetting = config.rules[ruleId];\n\n  // Rule not in config means use default (enabled)\n  if (ruleSetting === undefined) {\n    return true;\n  }\n\n  // Explicit false means disabled\n  if (ruleSetting === false) {\n    return false;\n  }\n\n  // true or severity string means enabled\n  return true;\n}\n\n/**\n * Get the severity for a rule, respecting overrides.\n *\n * @param config - Validator configuration\n * @param ruleId - Rule identifier\n * @param defaultSeverity - Default severity if not overridden\n * @returns The effective severity for the rule\n */\nexport function getRuleSeverity(\n  config: ValidatorConfig,\n  ruleId: string,\n  defaultSeverity: 'error' | 'warning' | 'suggestion'\n): 'error' | 'warning' | 'suggestion' {\n  const ruleSetting = config.rules[ruleId];\n\n  // If severity is explicitly set, use it\n  if (\n    ruleSetting === 'error' ||\n    ruleSetting === 'warning' ||\n    ruleSetting === 'suggestion'\n  ) {\n    return ruleSetting;\n  }\n\n  // Otherwise use default\n  return defaultSeverity;\n}\n","import { readFile } from 'node:fs/promises';\nimport { parse as parseYaml } from 'yaml';\nimport type { ToolDefinition, ToolSource } from '../types/index.js';\n\n/**\n * Supported file formats for tool definitions.\n */\nexport type FileFormat = 'json' | 'yaml';\n\n/**\n * Detected tool definition format.\n */\nexport type ToolFormat = 'single' | 'array' | 'manifest';\n\n/**\n * Parse a file containing MCP tool definitions.\n *\n * Supports JSON and YAML files containing:\n * - Single tool definition\n * - Array of tool definitions (bare array or { tools: [...] })\n * - Manifest format with server metadata ({ name, version, tools: [...] })\n *\n * @param filePath - Path to the file to parse\n * @returns Array of parsed tool definitions with source metadata\n * @throws Error if file format is unsupported or parsing fails\n */\nexport async function parseFile(filePath: string): Promise<ToolDefinition[]> {\n  // Validate format before reading to give clearer errors\n  const format = detectFormat(filePath);\n  const content = await readFile(filePath, 'utf-8');\n\n  let data: unknown;\n  try {\n    data = format === 'json' ? JSON.parse(content) : parseYaml(content);\n  } catch (error) {\n    const parseError = error as Error;\n    throw new Error(\n      `Failed to parse ${format.toUpperCase()} file \"${filePath}\": ${parseError.message}`\n    );\n  }\n\n  return normalizeToToolDefinitions(data, filePath);\n}\n\n/**\n * Detect file format from extension.\n *\n * @param filePath - Path to the file\n * @returns Detected file format\n * @throws Error if file extension is not supported\n */\nexport function detectFormat(filePath: string): FileFormat {\n  const lowerPath = filePath.toLowerCase();\n  if (lowerPath.endsWith('.json')) return 'json';\n  if (lowerPath.endsWith('.yaml') || lowerPath.endsWith('.yml')) return 'yaml';\n  throw new Error(\n    `Unsupported file format: \"${filePath}\". Expected .json, .yaml, or .yml extension.`\n  );\n}\n\n/**\n * Detect the format of parsed data.\n *\n * @param data - Parsed data to analyze\n * @returns Detected tool format\n */\nexport function detectToolFormat(data: unknown): ToolFormat {\n  // Bare array of tools\n  if (Array.isArray(data)) {\n    return 'array';\n  }\n\n  if (typeof data === 'object' && data !== null) {\n    const obj = data as Record<string, unknown>;\n\n    // Check if it's a manifest (has name/version and tools)\n    if ('tools' in obj && Array.isArray(obj.tools)) {\n      if ('name' in obj || 'version' in obj) {\n        return 'manifest';\n      }\n      return 'array';\n    }\n\n    // Single tool has name, description, inputSchema\n    if ('name' in obj && 'description' in obj && 'inputSchema' in obj) {\n      return 'single';\n    }\n  }\n\n  // Default to single for unknown structures (will be validated later)\n  return 'single';\n}\n\n/**\n * Check if an object looks like a valid tool definition.\n */\nfunction isToolLike(obj: unknown): obj is Record<string, unknown> {\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n  const record = obj as Record<string, unknown>;\n  return (\n    typeof record.name === 'string' &&\n    typeof record.description === 'string' &&\n    typeof record.inputSchema === 'object' &&\n    record.inputSchema !== null\n  );\n}\n\n/**\n * Convert a raw tool object to a ToolDefinition with source attached.\n */\nfunction toToolDefinition(\n  raw: Record<string, unknown>,\n  source: ToolSource\n): ToolDefinition {\n  return {\n    name: raw.name as string,\n    description: raw.description as string,\n    inputSchema: raw.inputSchema as Record<string, unknown>,\n    annotations: raw.annotations as ToolDefinition['annotations'],\n    source: {\n      ...source,\n      raw: raw,\n    },\n  };\n}\n\n/**\n * Normalize various tool definition formats to array of ToolDefinition.\n *\n * Supports:\n * - Single tool: { name, description, inputSchema }\n * - Array of tools: { tools: [...] } or just [...]\n * - Manifest: { name: \"server-name\", version: \"1.0.0\", tools: [...] }\n *\n * @param data - Parsed data in any supported format\n * @param sourcePath - Path to the source file\n * @returns Array of ToolDefinition with source attached\n * @throws Error if data structure is invalid\n */\nexport function normalizeToToolDefinitions(\n  data: unknown,\n  sourcePath: string\n): ToolDefinition[] {\n  const source: ToolSource = {\n    type: 'file',\n    location: sourcePath,\n    raw: data,\n  };\n\n  const format = detectToolFormat(data);\n\n  switch (format) {\n    case 'single': {\n      if (!isToolLike(data)) {\n        throw new Error(\n          `Invalid tool definition in \"${sourcePath}\": expected object with name, description, and inputSchema properties.`\n        );\n      }\n      return [toToolDefinition(data, source)];\n    }\n\n    case 'array': {\n      let tools: unknown[];\n\n      if (Array.isArray(data)) {\n        // Bare array format\n        tools = data;\n      } else {\n        // Object with tools array\n        const obj = data as Record<string, unknown>;\n        tools = obj.tools as unknown[];\n      }\n\n      if (tools.length === 0) {\n        return [];\n      }\n\n      return tools.map((tool, index) => {\n        if (!isToolLike(tool)) {\n          throw new Error(\n            `Invalid tool definition at index ${index} in \"${sourcePath}\": expected object with name, description, and inputSchema properties.`\n          );\n        }\n        return toToolDefinition(tool, source);\n      });\n    }\n\n    case 'manifest': {\n      const manifest = data as Record<string, unknown>;\n      const tools = manifest.tools as unknown[];\n\n      if (!Array.isArray(tools)) {\n        throw new Error(\n          `Invalid manifest in \"${sourcePath}\": tools property must be an array.`\n        );\n      }\n\n      if (tools.length === 0) {\n        return [];\n      }\n\n      return tools.map((tool, index) => {\n        if (!isToolLike(tool)) {\n          throw new Error(\n            `Invalid tool definition at index ${index} in manifest \"${sourcePath}\": expected object with name, description, and inputSchema properties.`\n          );\n        }\n        return toToolDefinition(tool, source);\n      });\n    }\n\n    default: {\n      throw new Error(\n        `Unable to parse tool definitions from \"${sourcePath}\": unrecognized format.`\n      );\n    }\n  }\n}\n","/**\n * MCP Client Module\n *\n * Connects to live MCP servers via STDIO or HTTP transport\n * to retrieve tool definitions.\n */\n\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';\nimport type { Transport } from '@modelcontextprotocol/sdk/shared/transport.js';\nimport type { ToolDefinition, ToolSource } from '../types/index.js';\n\n/**\n * Represents an active MCP connection.\n */\nexport interface MCPConnection {\n  /** The MCP client instance */\n  client: Client;\n  /** The transport layer (STDIO or HTTP) */\n  transport: Transport;\n}\n\n/**\n * Configuration for connecting to an MCP server.\n */\nexport interface ServerConfig {\n  /** Server URL (http/https) or command to execute (for stdio) */\n  server: string;\n  /** Optional timeout in milliseconds (default: 30000) */\n  timeout?: number;\n}\n\n/**\n * Detect if a server string represents an HTTP URL or a STDIO command.\n *\n * @param server - The server string to analyze\n * @returns true if HTTP/HTTPS URL, false for STDIO command\n */\nfunction isHttpServer(server: string): boolean {\n  return server.startsWith('http://') || server.startsWith('https://');\n}\n\n/**\n * Connect to an MCP server.\n *\n * Supports two transport types:\n * - **STDIO transport**: For commands like \"node server.js\", \"python server.py\"\n * - **HTTP transport**: For URLs like \"http://localhost:3000/mcp\", \"https://...\"\n *\n * @param config - Server configuration\n * @returns MCP connection object\n * @throws Error if connection fails\n *\n * @example\n * ```typescript\n * // Connect to STDIO server\n * const conn = await connectToServer({ server: 'node my-server.js' });\n *\n * // Connect to HTTP server\n * const conn = await connectToServer({ server: 'http://localhost:3000/mcp' });\n * ```\n */\nexport async function connectToServer(config: ServerConfig): Promise<MCPConnection> {\n  const { server, timeout = 30000 } = config;\n\n  let transport: Transport;\n\n  if (isHttpServer(server)) {\n    // HTTP/Streamable HTTP transport\n    transport = new StreamableHTTPClientTransport(new URL(server));\n  } else {\n    // STDIO transport - parse command and args\n    const parts = server.split(/\\s+/);\n    const command = parts[0];\n    const args = parts.slice(1);\n\n    transport = new StdioClientTransport({\n      command,\n      args,\n    });\n  }\n\n  const client = new Client(\n    {\n      name: 'mcp-tool-validator',\n      version: '0.1.0',\n    },\n    {\n      capabilities: {},\n    }\n  );\n\n  // Connect with timeout\n  const connectPromise = client.connect(transport);\n\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    setTimeout(() => {\n      reject(new Error(`Connection to MCP server timed out after ${timeout}ms`));\n    }, timeout);\n  });\n\n  await Promise.race([connectPromise, timeoutPromise]);\n\n  return { client, transport };\n}\n\n/**\n * Get tool definitions from a connected MCP server.\n *\n * @param connection - Active MCP connection\n * @param serverUrl - Server URL/command for source tracking\n * @returns Array of tool definitions\n */\nexport async function getToolDefinitions(\n  connection: MCPConnection,\n  serverUrl: string\n): Promise<ToolDefinition[]> {\n  const response = await connection.client.listTools();\n\n  return response.tools.map((tool) => {\n    const source: ToolSource = {\n      type: 'server',\n      location: serverUrl,\n      raw: tool,\n    };\n\n    return {\n      name: tool.name,\n      description: tool.description ?? '',\n      inputSchema: tool.inputSchema as Record<string, unknown>,\n      annotations: tool.annotations\n        ? {\n            title: tool.annotations.title,\n            readOnlyHint: tool.annotations.readOnlyHint,\n            destructiveHint: tool.annotations.destructiveHint,\n            idempotentHint: tool.annotations.idempotentHint,\n            openWorldHint: tool.annotations.openWorldHint,\n          }\n        : undefined,\n      source,\n    };\n  });\n}\n\n/**\n * Disconnect from an MCP server.\n *\n * @param connection - Active MCP connection to close\n */\nexport async function disconnect(connection: MCPConnection): Promise<void> {\n  await connection.client.close();\n}\n\n/**\n * Convenience function to connect, get tools, and disconnect.\n *\n * @param config - Server configuration\n * @returns Array of tool definitions\n *\n * @example\n * ```typescript\n * const tools = await fetchToolsFromServer({ server: 'http://localhost:3000/mcp' });\n * console.log(`Found ${tools.length} tools`);\n * ```\n */\nexport async function fetchToolsFromServer(config: ServerConfig): Promise<ToolDefinition[]> {\n  const connection = await connectToServer(config);\n  try {\n    return await getToolDefinitions(connection, config.server);\n  } finally {\n    await disconnect(connection);\n  }\n}\n","/**\n * Rule Registry\n *\n * Registry mapping rule IDs to their module paths.\n * Rules are loaded on-demand based on configuration.\n */\n\nimport type { Rule } from './types.js';\n\n/**\n * Module result type for dynamic rule imports.\n */\nexport interface RuleModule {\n  default: Rule;\n}\n\n/**\n * Registry mapping rule IDs to their module paths (relative to this file).\n * Rules are loaded on-demand based on configuration.\n */\nexport const RULE_PATHS: Record<string, string> = {\n  // Schema rules (8 rules)\n  'SCH-001': './schema/sch-001.js',\n  'SCH-002': './schema/sch-002.js',\n  'SCH-003': './schema/sch-003.js',\n  'SCH-004': './schema/sch-004.js',\n  'SCH-005': './schema/sch-005.js',\n  'SCH-006': './schema/sch-006.js',\n  'SCH-007': './schema/sch-007.js',\n  'SCH-008': './schema/sch-008.js',\n\n  // Naming rules (6 rules)\n  'NAM-001': './naming/nam-001.js',\n  'NAM-002': './naming/nam-002.js',\n  'NAM-003': './naming/nam-003.js',\n  'NAM-004': './naming/nam-004.js',\n  'NAM-005': './naming/nam-005.js',\n  'NAM-006': './naming/nam-006.js',\n\n  // Security rules (10 rules)\n  'SEC-001': './security/sec-001.js',\n  'SEC-002': './security/sec-002.js',\n  'SEC-003': './security/sec-003.js',\n  'SEC-004': './security/sec-004.js',\n  'SEC-005': './security/sec-005.js',\n  'SEC-006': './security/sec-006.js',\n  'SEC-007': './security/sec-007.js',\n  'SEC-008': './security/sec-008.js',\n  'SEC-009': './security/sec-009.js',\n  'SEC-010': './security/sec-010.js',\n\n  // LLM Compatibility rules (12 rules)\n  'LLM-001': './llm-compatibility/llm-001.js',\n  'LLM-002': './llm-compatibility/llm-002.js',\n  'LLM-003': './llm-compatibility/llm-003.js',\n  'LLM-004': './llm-compatibility/llm-004.js',\n  'LLM-005': './llm-compatibility/llm-005.js',\n  'LLM-006': './llm-compatibility/llm-006.js',\n  'LLM-007': './llm-compatibility/llm-007.js',\n  'LLM-008': './llm-compatibility/llm-008.js',\n  'LLM-009': './llm-compatibility/llm-009.js',\n  'LLM-010': './llm-compatibility/llm-010.js',\n  'LLM-011': './llm-compatibility/llm-011.js',\n  'LLM-012': './llm-compatibility/llm-012.js',\n\n  // Best practice rules (8 rules)\n  'BP-001': './best-practice/bp-001.js',\n  'BP-002': './best-practice/bp-002.js',\n  'BP-003': './best-practice/bp-003.js',\n  'BP-004': './best-practice/bp-004.js',\n  'BP-005': './best-practice/bp-005.js',\n  'BP-006': './best-practice/bp-006.js',\n  'BP-007': './best-practice/bp-007.js',\n  'BP-008': './best-practice/bp-008.js',\n};\n\n/**\n * Get all registered rule IDs.\n */\nexport function getAllRuleIds(): string[] {\n  return Object.keys(RULE_PATHS);\n}\n\n/**\n * Check if a rule ID is registered.\n */\nexport function isRuleRegistered(ruleId: string): boolean {\n  return ruleId in RULE_PATHS;\n}\n\n/**\n * Load a rule module by ID.\n * Returns null if the rule cannot be loaded (module doesn't exist yet).\n */\nexport async function loadRuleModule(ruleId: string): Promise<Rule | null> {\n  const path = RULE_PATHS[ruleId];\n  if (!path) {\n    return null;\n  }\n\n  try {\n    // Use dynamic import with the path\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    const module: RuleModule = await import(path);\n    return module.default;\n  } catch {\n    // Rule module doesn't exist yet - skip gracefully\n    return null;\n  }\n}\n","/**\n * Rule Loader\n *\n * Loads validation rules based on configuration.\n * Only loads rules that are enabled (not set to false).\n */\n\nimport type { Rule } from '../rules/types.js';\nimport type { RuleConfig, IssueSeverity } from '../types/index.js';\nimport {\n  RULE_PATHS,\n  isRuleRegistered,\n  loadRuleModule,\n} from '../rules/index.js';\n\n/**\n * Load rules based on configuration.\n * Only loads rules that are enabled (not set to false).\n */\nexport async function loadRules(config: RuleConfig): Promise<Rule[]> {\n  const rulesToLoad = new Set<string>();\n\n  // Determine which rules to load from config\n  for (const [ruleId, setting] of Object.entries(config)) {\n    if (setting !== false && isRuleRegistered(ruleId)) {\n      rulesToLoad.add(ruleId);\n    }\n  }\n\n  // Also load any rules that aren't explicitly configured (use defaults)\n  for (const ruleId of Object.keys(RULE_PATHS)) {\n    if (!(ruleId in config)) {\n      rulesToLoad.add(ruleId);\n    }\n  }\n\n  // Load rules in parallel\n  const loadedRules = await Promise.all(\n    Array.from(rulesToLoad).map((ruleId) => loadRuleModule(ruleId))\n  );\n\n  return loadedRules.filter((rule): rule is Rule => rule !== null);\n}\n\n/**\n * Get the effective severity for a rule based on config.\n * Config can override the rule's default severity.\n */\nexport function getEffectiveSeverity(\n  rule: Rule,\n  config: RuleConfig\n): IssueSeverity {\n  const setting = config[rule.id];\n  if (typeof setting === 'string') {\n    return setting; // Config overrides severity\n  }\n  return rule.defaultSeverity;\n}\n","/**\n * Rule Engine\n *\n * Executes validation rules against tools and aggregates results.\n */\n\nimport type { Rule, RuleContext, ToolRuleResults } from '../rules/types.js';\nimport type {\n  ToolDefinition,\n  ValidationIssue,\n  RuleConfig,\n  ValidationSummary,\n  IssueCategory,\n  IssueSeverity,\n} from '../types/index.js';\nimport { getEffectiveSeverity } from './rule-loader.js';\n\n/**\n * Execute all loaded rules against a set of tools.\n */\nexport function executeRules(\n  tools: ToolDefinition[],\n  rules: Rule[],\n  config: RuleConfig\n): ToolRuleResults[] {\n  const results: ToolRuleResults[] = [];\n\n  for (const tool of tools) {\n    const issues: ValidationIssue[] = [];\n\n    for (const rule of rules) {\n      // Skip if rule is disabled\n      if (config[rule.id] === false) continue;\n\n      const ctx: RuleContext = {\n        allTools: tools,\n        ruleConfig: config[rule.id] ?? true,\n      };\n\n      const ruleIssues = rule.check(tool, ctx);\n\n      // Apply effective severity from config\n      const effectiveSeverity = getEffectiveSeverity(rule, config);\n      for (const issue of ruleIssues) {\n        issues.push({\n          ...issue,\n          severity: effectiveSeverity,\n        });\n      }\n    }\n\n    results.push({ tool, issues });\n  }\n\n  return results;\n}\n\n/**\n * Aggregate results into a validation summary.\n */\nexport function aggregateResults(results: ToolRuleResults[]): ValidationSummary {\n  const issuesByCategory: Record<IssueCategory, number> = {\n    'schema': 0,\n    'security': 0,\n    'llm-compatibility': 0,\n    'naming': 0,\n    'best-practice': 0,\n  };\n\n  const issuesBySeverity: Record<IssueSeverity, number> = {\n    'error': 0,\n    'warning': 0,\n    'suggestion': 0,\n  };\n\n  let validTools = 0;\n\n  for (const result of results) {\n    const hasErrors = result.issues.some((i) => i.severity === 'error');\n    if (!hasErrors) validTools++;\n\n    for (const issue of result.issues) {\n      issuesByCategory[issue.category]++;\n      issuesBySeverity[issue.severity]++;\n    }\n  }\n\n  return {\n    totalTools: results.length,\n    validTools,\n    issuesByCategory,\n    issuesBySeverity,\n  };\n}\n\n/**\n * Flatten all issues from results.\n */\nexport function flattenIssues(results: ToolRuleResults[]): ValidationIssue[] {\n  return results.flatMap((r) => r.issues);\n}\n","/**\n * Core Validator Module\n *\n * Main validation orchestrator that coordinates configuration loading,\n * rule execution, and result aggregation.\n */\n\nimport type {\n  ToolDefinition,\n  ValidationResult,\n  ValidatorConfig,\n  ValidationMetadata,\n  ToolValidationResult,\n} from '../types/index.js';\nimport { loadConfig, mergeConfig, getDefaultConfig } from './config.js';\nimport { loadRules } from './rule-loader.js';\nimport { executeRules, aggregateResults, flattenIssues } from './rule-engine.js';\nimport { parseFile } from '../parsers/file.js';\nimport { fetchToolsFromServer } from '../parsers/mcp-client.js';\n\n// Package version (should match package.json)\nconst VALIDATOR_VERSION = '0.1.0';\nconst MCP_SPEC_VERSION = '2025-11-25';\n\n/**\n * Options for validation functions.\n */\nexport interface ValidateOptions {\n  /** Override default config */\n  config?: Partial<ValidatorConfig>;\n  /** Load config from file path */\n  configPath?: string;\n}\n\n/**\n * Validate tool definitions directly.\n *\n * This is the main entry point for programmatic validation.\n * Validates an array of tool definitions and returns a complete validation result.\n *\n * @param tools - Array of tool definitions to validate\n * @param options - Optional configuration overrides\n * @returns Complete validation result with issues, summary, and metadata\n *\n * @example\n * ```typescript\n * import { validate } from 'mcp-tool-validator';\n *\n * const tools = [{\n *   name: 'my-tool',\n *   description: 'Does something useful',\n *   inputSchema: { type: 'object', properties: {} },\n *   source: { type: 'file', location: 'tools.json', raw: {} }\n * }];\n *\n * const result = await validate(tools);\n * if (!result.valid) {\n *   console.log('Validation errors:', result.issues);\n * }\n * ```\n */\nexport async function validate(\n  tools: ToolDefinition[],\n  options: ValidateOptions = {}\n): Promise<ValidationResult> {\n  const startTime = Date.now();\n\n  // Load and merge config\n  let config: ValidatorConfig;\n  if (options.configPath) {\n    const loaded = await loadConfig(options.configPath);\n    config = loaded.config;\n  } else {\n    config = getDefaultConfig();\n  }\n\n  // Apply any inline config overrides\n  if (options.config) {\n    config = mergeConfig({ ...config, ...options.config });\n  }\n\n  // Load enabled rules based on config\n  const rules = await loadRules(config.rules);\n\n  // Execute rules against all tools\n  const toolResults = executeRules(tools, rules, config.rules);\n\n  // Build per-tool results\n  const toolValidationResults: ToolValidationResult[] = toolResults.map((tr) => ({\n    name: tr.tool.name,\n    valid: !tr.issues.some((i) => i.severity === 'error'),\n    tool: tr.tool,\n    issues: tr.issues,\n  }));\n\n  // Aggregate summary statistics\n  const summary = aggregateResults(toolResults);\n  const allIssues = flattenIssues(toolResults);\n\n  // Build metadata\n  const metadata: ValidationMetadata = {\n    validatorVersion: VALIDATOR_VERSION,\n    mcpSpecVersion: MCP_SPEC_VERSION,\n    timestamp: new Date().toISOString(),\n    duration: Date.now() - startTime,\n    configUsed: options.configPath || '',\n    llmAnalysisUsed: false,\n  };\n\n  return {\n    valid: summary.issuesBySeverity.error === 0,\n    summary,\n    issues: allIssues,\n    tools: toolValidationResults,\n    metadata,\n  };\n}\n\n/**\n * Validate tool definitions from a file (JSON or YAML).\n *\n * Loads and parses the file, then validates all tool definitions found.\n * Supports single tool, array of tools, or manifest format.\n *\n * @param filePath - Path to the file to validate\n * @param options - Optional configuration overrides\n * @returns Complete validation result\n *\n * @example\n * ```typescript\n * import { validateFile } from 'mcp-tool-validator';\n *\n * const result = await validateFile('./tools.json');\n * console.log(`Validated ${result.summary.totalTools} tools`);\n * ```\n */\nexport async function validateFile(\n  filePath: string,\n  options: ValidateOptions = {}\n): Promise<ValidationResult> {\n  const tools = await parseFile(filePath);\n  return validate(tools, options);\n}\n\n/**\n * Validate tool definitions from a live MCP server.\n *\n * Connects to the server, retrieves tool definitions, and validates them.\n * Supports both STDIO and HTTP transports.\n *\n * @param serverUrl - Server URL (http/https) or command to execute (for STDIO)\n * @param options - Optional configuration overrides\n * @returns Complete validation result\n *\n * @example\n * ```typescript\n * import { validateServer } from 'mcp-tool-validator';\n *\n * // HTTP server\n * const result = await validateServer('http://localhost:3000/mcp');\n *\n * // STDIO server\n * const result = await validateServer('node ./my-server.js');\n * ```\n */\nexport async function validateServer(\n  serverUrl: string,\n  options: ValidateOptions = {}\n): Promise<ValidationResult> {\n  const tools = await fetchToolsFromServer({ server: serverUrl });\n  return validate(tools, options);\n}\n","import chalk, { Chalk } from 'chalk';\nimport type { ValidationResult } from '../types/index.js';\n\nexport interface HumanOutputOptions {\n  color?: boolean;\n  verbose?: boolean;\n}\n\n/**\n * Format validation results for human-readable terminal output\n */\nexport function formatHumanOutput(result: ValidationResult, options: HumanOutputOptions = {}): string {\n  const { color = true, verbose = false } = options;\n  const c = color ? chalk : new Chalk({ level: 0 });\n\n  const lines: string[] = [];\n\n  // Header\n  lines.push(`MCP Tool Validator v${result.metadata.validatorVersion}`);\n  lines.push(c.gray('─'.repeat(50)));\n  lines.push('');\n\n  // Source info\n  lines.push(`Validating: ${result.tools.length} tool(s)`);\n  lines.push('');\n\n  // Per-tool results\n  for (const toolResult of result.tools) {\n    const hasErrors = toolResult.issues.some(i => i.severity === 'error');\n    const icon = hasErrors ? c.red('✗') : c.green('✓');\n    lines.push(`${icon} ${toolResult.tool.name}`);\n\n    for (const issue of toolResult.issues) {\n      const severityColor = issue.severity === 'error' ? c.red :\n                           issue.severity === 'warning' ? c.yellow : c.blue;\n      const severityLabel = issue.severity.toUpperCase();\n\n      lines.push(`  ${severityColor(severityLabel)} [${issue.id}] ${issue.message}`);\n\n      if (issue.path) {\n        lines.push(`    ${c.gray('at:')} ${issue.path}`);\n      }\n\n      if (issue.suggestion && verbose) {\n        lines.push(`    ${c.gray('suggestion:')} ${issue.suggestion}`);\n      }\n    }\n\n    lines.push('');\n  }\n\n  // Summary\n  lines.push(c.gray('─'.repeat(50)));\n  lines.push(`Summary: ${result.summary.validTools}/${result.summary.totalTools} tools valid`);\n  lines.push('');\n\n  lines.push(`  Errors:      ${result.summary.issuesBySeverity.error}`);\n  lines.push(`  Warnings:    ${result.summary.issuesBySeverity.warning}`);\n  lines.push(`  Suggestions: ${result.summary.issuesBySeverity.suggestion}`);\n  lines.push('');\n\n  lines.push('  By Category:');\n  for (const [category, count] of Object.entries(result.summary.issuesByCategory)) {\n    if (count > 0) {\n      lines.push(`    ${category}: ${count}`);\n    }\n  }\n  lines.push('');\n\n  // Final status\n  if (result.valid) {\n    lines.push(c.green('Validation passed.'));\n  } else {\n    lines.push(c.red(`Validation failed with ${result.summary.issuesBySeverity.error} error(s).`));\n  }\n\n  return lines.join('\\n');\n}\n","import type { ValidationResult } from '../types/index.js';\n\n/**\n * Format validation results as JSON\n */\nexport function formatJsonOutput(result: ValidationResult): string {\n  return JSON.stringify(result, null, 2);\n}\n","import type { ValidationResult, ValidationIssue } from '../types/index.js';\n\n/**\n * SARIF 2.1.0 output format\n * https://docs.oasis-open.org/sarif/sarif/v2.1.0/sarif-v2.1.0.html\n */\nexport interface SarifLog {\n  $schema: string;\n  version: '2.1.0';\n  runs: SarifRun[];\n}\n\nexport interface SarifRun {\n  tool: {\n    driver: {\n      name: string;\n      version: string;\n      informationUri?: string;\n      rules: SarifRule[];\n    };\n  };\n  results: SarifResult[];\n}\n\nexport interface SarifRule {\n  id: string;\n  name: string;\n  shortDescription: { text: string };\n  defaultConfiguration?: {\n    level: 'error' | 'warning' | 'note';\n  };\n}\n\nexport interface SarifResult {\n  ruleId: string;\n  level: 'error' | 'warning' | 'note';\n  message: { text: string };\n  locations?: Array<{\n    physicalLocation?: {\n      artifactLocation?: { uri?: string };\n    };\n    logicalLocations?: Array<{\n      name?: string;\n      kind?: string;\n      fullyQualifiedName?: string;\n    }>;\n  }>;\n}\n\n/**\n * Map severity to SARIF level\n */\nfunction severityToSarifLevel(severity: string): 'error' | 'warning' | 'note' {\n  switch (severity) {\n    case 'error': return 'error';\n    case 'warning': return 'warning';\n    default: return 'note';\n  }\n}\n\n/**\n * Format validation results as SARIF 2.1.0\n */\nexport function formatSarifOutput(result: ValidationResult): string {\n  // Collect unique rules from all issues\n  const uniqueRules = new Map<string, ValidationIssue>();\n  for (const toolResult of result.tools) {\n    for (const issue of toolResult.issues) {\n      if (!uniqueRules.has(issue.id)) {\n        uniqueRules.set(issue.id, issue);\n      }\n    }\n  }\n\n  const rules: SarifRule[] = Array.from(uniqueRules.values()).map(issue => ({\n    id: issue.id,\n    name: issue.id,\n    shortDescription: { text: issue.message },\n    defaultConfiguration: {\n      level: severityToSarifLevel(issue.severity),\n    },\n  }));\n\n  const results: SarifResult[] = [];\n  for (const toolResult of result.tools) {\n    for (const issue of toolResult.issues) {\n      results.push({\n        ruleId: issue.id,\n        level: severityToSarifLevel(issue.severity),\n        message: { text: issue.message },\n        locations: [{\n          logicalLocations: [{\n            name: issue.tool,\n            kind: 'tool',\n            fullyQualifiedName: issue.path ? `${issue.tool}.${issue.path}` : issue.tool,\n          }],\n        }],\n      });\n    }\n  }\n\n  const sarif: SarifLog = {\n    $schema: 'https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json',\n    version: '2.1.0',\n    runs: [{\n      tool: {\n        driver: {\n          name: 'mcp-tool-validator',\n          version: result.metadata.validatorVersion,\n          informationUri: 'https://github.com/example/mcp-tool-validator',\n          rules,\n        },\n      },\n      results,\n    }],\n  };\n\n  return JSON.stringify(sarif, null, 2);\n}\n"],"mappings":"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","names":[]}